//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.2.1
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


public class VisionParam : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal VisionParam(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(VisionParam obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(VisionParam obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~VisionParam() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          nrc_interfacePINVOKE.delete_VisionParam(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public class CameraList : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal CameraList(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(CameraList obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef swigRelease(CameraList obj) {
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
        global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.Dispose();
        return ptr;
      } else {
        return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  
    ~CameraList() {
      Dispose(false);
    }
  
    public void Dispose() {
      Dispose(true);
      global::System.GC.SuppressFinalize(this);
    }
  
    protected virtual void Dispose(bool disposing) {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            nrc_interfacePINVOKE.delete_VisionParam_CameraList(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
      }
    }
  
    public string currentName {
      set {
        nrc_interfacePINVOKE.VisionParam_CameraList_currentName_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_CameraList_currentName_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public int listNum {
      set {
        nrc_interfacePINVOKE.VisionParam_CameraList_listNum_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_CameraList_listNum_get(swigCPtr);
        return ret;
      } 
    }
  
    public CameraList() : this(nrc_interfacePINVOKE.new_VisionParam_CameraList(), true) {
    }
  
  }

  public VisionParam.CameraList cameraList {
    set {
      nrc_interfacePINVOKE.VisionParam_cameraList_set(swigCPtr, VisionParam.CameraList.getCPtr(value));
    } 
    get {
      global::System.IntPtr cPtr = nrc_interfacePINVOKE.VisionParam_cameraList_get(swigCPtr);
      VisionParam.CameraList ret = (cPtr == global::System.IntPtr.Zero) ? null : new VisionParam.CameraList(cPtr, false);
      return ret;
    } 
  }

  public class Protocol : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal Protocol(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Protocol obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef swigRelease(Protocol obj) {
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
        global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.Dispose();
        return ptr;
      } else {
        return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  
    ~Protocol() {
      Dispose(false);
    }
  
    public void Dispose() {
      Dispose(true);
      global::System.GC.SuppressFinalize(this);
    }
  
    protected virtual void Dispose(bool disposing) {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            nrc_interfacePINVOKE.delete_VisionParam_Protocol(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
      }
    }
  
    public string addDataInitialPara {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_addDataInitialPara_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Protocol_addDataInitialPara_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public int addDataNum {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_addDataNum_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Protocol_addDataNum_get(swigCPtr);
        return ret;
      } 
    }
  
    public int angleUnit {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_angleUnit_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Protocol_angleUnit_get(swigCPtr);
        return ret;
      } 
    }
  
    public string endMark {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_endMark_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Protocol_endMark_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public string failFlag {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_failFlag_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Protocol_failFlag_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public string frameHeader {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_frameHeader_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Protocol_frameHeader_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public bool hasTCS {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_hasTCS_set(swigCPtr, value);
      } 
      get {
        bool ret = nrc_interfacePINVOKE.VisionParam_Protocol_hasTCS_get(swigCPtr);
        return ret;
      } 
    }
  
    public bool hasUCS {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_hasUCS_set(swigCPtr, value);
      } 
      get {
        bool ret = nrc_interfacePINVOKE.VisionParam_Protocol_hasUCS_get(swigCPtr);
        return ret;
      } 
    }
  
    public string separator {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_separator_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Protocol_separator_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public bool singleTarget {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_singleTarget_set(swigCPtr, value);
      } 
      get {
        bool ret = nrc_interfacePINVOKE.VisionParam_Protocol_singleTarget_get(swigCPtr);
        return ret;
      } 
    }
  
    public string successFlag {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_successFlag_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Protocol_successFlag_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public int timeOut {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_timeOut_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Protocol_timeOut_get(swigCPtr);
        return ret;
      } 
    }
  
    public int type {
      set {
        nrc_interfacePINVOKE.VisionParam_Protocol_type_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Protocol_type_get(swigCPtr);
        return ret;
      } 
    }
  
    public Protocol() : this(nrc_interfacePINVOKE.new_VisionParam_Protocol(), true) {
    }
  
  }

  public VisionParam.Protocol protocol {
    set {
      nrc_interfacePINVOKE.VisionParam_protocol_set(swigCPtr, VisionParam.Protocol.getCPtr(value));
    } 
    get {
      global::System.IntPtr cPtr = nrc_interfacePINVOKE.VisionParam_protocol_get(swigCPtr);
      VisionParam.Protocol ret = (cPtr == global::System.IntPtr.Zero) ? null : new VisionParam.Protocol(cPtr, false);
      return ret;
    } 
  }

  public class Socket : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal Socket(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Socket obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef swigRelease(Socket obj) {
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
        global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.Dispose();
        return ptr;
      } else {
        return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  
    ~Socket() {
      Dispose(false);
    }
  
    public void Dispose() {
      Dispose(true);
      global::System.GC.SuppressFinalize(this);
    }
  
    protected virtual void Dispose(bool disposing) {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            nrc_interfacePINVOKE.delete_VisionParam_Socket(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
      }
    }
  
    public string IP {
      set {
        nrc_interfacePINVOKE.VisionParam_Socket_IP_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Socket_IP_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public int cameraDataType {
      set {
        nrc_interfacePINVOKE.VisionParam_Socket_cameraDataType_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Socket_cameraDataType_get(swigCPtr);
        return ret;
      } 
    }
  
    public int portNum {
      set {
        nrc_interfacePINVOKE.VisionParam_Socket_portNum_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Socket_portNum_get(swigCPtr);
        return ret;
      } 
    }
  
    public int portOne {
      set {
        nrc_interfacePINVOKE.VisionParam_Socket_portOne_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Socket_portOne_get(swigCPtr);
        return ret;
      } 
    }
  
    public int portTwo {
      set {
        nrc_interfacePINVOKE.VisionParam_Socket_portTwo_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Socket_portTwo_get(swigCPtr);
        return ret;
      } 
    }
  
    public bool server {
      set {
        nrc_interfacePINVOKE.VisionParam_Socket_server_set(swigCPtr, value);
      } 
      get {
        bool ret = nrc_interfacePINVOKE.VisionParam_Socket_server_get(swigCPtr);
        return ret;
      } 
    }
  
    public Socket() : this(nrc_interfacePINVOKE.new_VisionParam_Socket(), true) {
    }
  
  }

  public VisionParam.Socket socket {
    set {
      nrc_interfacePINVOKE.VisionParam_socket_set(swigCPtr, VisionParam.Socket.getCPtr(value));
    } 
    get {
      global::System.IntPtr cPtr = nrc_interfacePINVOKE.VisionParam_socket_get(swigCPtr);
      VisionParam.Socket ret = (cPtr == global::System.IntPtr.Zero) ? null : new VisionParam.Socket(cPtr, false);
      return ret;
    } 
  }

  public class Trigger : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal Trigger(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Trigger obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef swigRelease(Trigger obj) {
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
        global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.Dispose();
        return ptr;
      } else {
        return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  
    ~Trigger() {
      Dispose(false);
    }
  
    public void Dispose() {
      Dispose(true);
      global::System.GC.SuppressFinalize(this);
    }
  
    protected virtual void Dispose(bool disposing) {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            nrc_interfacePINVOKE.delete_VisionParam_Trigger(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
      }
    }
  
    public int IOPort {
      set {
        nrc_interfacePINVOKE.VisionParam_Trigger_IOPort_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Trigger_IOPort_get(swigCPtr);
        return ret;
      } 
    }
  
    public int duration {
      set {
        nrc_interfacePINVOKE.VisionParam_Trigger_duration_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Trigger_duration_get(swigCPtr);
        return ret;
      } 
    }
  
    public int intervals {
      set {
        nrc_interfacePINVOKE.VisionParam_Trigger_intervals_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Trigger_intervals_get(swigCPtr);
        return ret;
      } 
    }
  
    public int triggerMode {
      set {
        nrc_interfacePINVOKE.VisionParam_Trigger_triggerMode_set(swigCPtr, value);
      } 
      get {
        int ret = nrc_interfacePINVOKE.VisionParam_Trigger_triggerMode_get(swigCPtr);
        return ret;
      } 
    }
  
    public bool triggerOnce {
      set {
        nrc_interfacePINVOKE.VisionParam_Trigger_triggerOnce_set(swigCPtr, value);
      } 
      get {
        bool ret = nrc_interfacePINVOKE.VisionParam_Trigger_triggerOnce_get(swigCPtr);
        return ret;
      } 
    }
  
    public string triggerStr {
      set {
        nrc_interfacePINVOKE.VisionParam_Trigger_triggerStr_set(swigCPtr, value);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
      } 
      get {
        string ret = nrc_interfacePINVOKE.VisionParam_Trigger_triggerStr_get(swigCPtr);
        if (nrc_interfacePINVOKE.SWIGPendingException.Pending) throw nrc_interfacePINVOKE.SWIGPendingException.Retrieve();
        return ret;
      } 
    }
  
    public Trigger() : this(nrc_interfacePINVOKE.new_VisionParam_Trigger(), true) {
    }
  
  }

  public VisionParam.Trigger trigger {
    set {
      nrc_interfacePINVOKE.VisionParam_trigger_set(swigCPtr, VisionParam.Trigger.getCPtr(value));
    } 
    get {
      global::System.IntPtr cPtr = nrc_interfacePINVOKE.VisionParam_trigger_get(swigCPtr);
      VisionParam.Trigger ret = (cPtr == global::System.IntPtr.Zero) ? null : new VisionParam.Trigger(cPtr, false);
      return ret;
    } 
  }

  public int userCoordNum {
    set {
      nrc_interfacePINVOKE.VisionParam_userCoordNum_set(swigCPtr, value);
    } 
    get {
      int ret = nrc_interfacePINVOKE.VisionParam_userCoordNum_get(swigCPtr);
      return ret;
    } 
  }

  public VisionParam() : this(nrc_interfacePINVOKE.new_VisionParam(), true) {
  }

}
